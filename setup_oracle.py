import os
import oracledb
from dotenv import load_dotenv

# Load environment variables
load_dotenv(r'c:\big20\final\.env')

def get_connection():
    try:
        host = os.getenv('ORACLE_HOST')
        port = os.getenv('ORACLE_PORT')
        service = os.getenv('ORACLE_SERVICE_NAME')
        user = os.getenv('ORACLE_USER')
        
        print(f"Connecting to Oracle at {host}:{port}/{service} as {user}...")
        
        dsn = f"{host}:{port}/{service}"
        conn = oracledb.connect(
            user=user,
            password=os.getenv("ORACLE_PASSWORD"),
            dsn=dsn
        )
        print("Connected to Oracle DB successfully.")
        return conn
    except Exception as e:
        print(f"Connection failed: {e}")
        return None

def execute_sql(cursor, sql, params=None):
    try:
        if params:
            cursor.execute(sql, params)
        else:
            cursor.execute(sql)
        print(f"Executed: {sql[:50]}...")
    except oracledb.DatabaseError as e:
        error, = e.args
        # Ignore "table or view does not exist" errors during drop
        if error.code != 942:
            print(f"Error executing {sql[:50]}...: {e}")

def setup_db():
    with open(r'c:\big20\final\setup_log.txt', 'w', encoding='utf-8') as f:
        f.write("Starting setup...\n")
        
    def log(msg):
        print(msg)
        with open(r'c:\big20\final\setup_log.txt', 'a', encoding='utf-8') as f:
            f.write(msg + "\n")
            
    conn = get_connection()
    if not conn:
        log("Connection failed.")
        return

    cursor = conn.cursor()

    # 1. Drop Tables (Reverse Order)
    tables = [
        "interview_evaluations", "interview_questions", "rubric_levels", 
        "evaluation_items", "company_tech_stacks", "job_postings", 
        "rubric_categories", "companies", "job_roles"
    ]
    
    log("\n--- Dropping Tables ---")
    for table in tables:
        try:
            cursor.execute(f"DROP TABLE {table} CASCADE CONSTRAINTS")
            log(f"Dropped {table}")
        except oracledb.DatabaseError as e:
            error, = e.args
            if error.code != 942:
                log(f"Error dropping {table}: {e}")

    # 2. Create Tables
    log("\n--- Creating Tables ---")
    
    ddl_statements = [
        """
        CREATE TABLE job_roles (
            role_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            role_name VARCHAR2(50) NOT NULL UNIQUE,
            description CLOB
        )
        """,
        """
        CREATE TABLE companies (
            company_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            name VARCHAR2(100) NOT NULL,
            industry VARCHAR2(50),
            vision CLOB,
            core_values CLOB,
            homepage_url VARCHAR2(255)
        )
        """,
        """
        CREATE TABLE rubric_categories (
            category_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            name VARCHAR2(100) NOT NULL,
            description CLOB,
            weight NUMBER DEFAULT 1.0
        )
        """,
        """
        CREATE TABLE job_postings (
            posting_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            company_id NUMBER REFERENCES companies(company_id) ON DELETE CASCADE,
            role_id NUMBER REFERENCES job_roles(role_id),
            title VARCHAR2(200) NOT NULL,
            requirements CLOB,
            preferred_qualifications CLOB,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        """,
        """
        CREATE TABLE company_tech_stacks (
            company_id NUMBER REFERENCES companies(company_id) ON DELETE CASCADE,
            tech_name VARCHAR2(50),
            PRIMARY KEY (company_id, tech_name)
        )
        """,
        """
        CREATE TABLE evaluation_items (
            item_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            category_id NUMBER REFERENCES rubric_categories(category_id),
            item_name VARCHAR2(200) NOT NULL,
            definition CLOB
        )
        """,
        """
        CREATE TABLE rubric_levels (
            level_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            item_id NUMBER REFERENCES evaluation_items(item_id) ON DELETE CASCADE,
            score NUMBER NOT NULL,
            description CLOB
        )
        """,
        """
        CREATE TABLE interview_questions (
            question_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            role_id NUMBER REFERENCES job_roles(role_id),
            category_id NUMBER REFERENCES rubric_categories(category_id),
            question_text CLOB NOT NULL,
            intent CLOB,
            ideal_answer CLOB
        )
        """,
        """
        CREATE TABLE interview_evaluations (
            evaluation_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            session_id NUMBER NOT NULL,
            item_id NUMBER REFERENCES evaluation_items(item_id),
            score NUMBER NOT NULL,
            feedback CLOB,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        """
    ]

    for ddl in ddl_statements:
        try:
            cursor.execute(ddl)
            log(f"Executed DDL: {ddl.strip()[:30]}...")
        except Exception as e:
            log(f"Error DDL: {e}")

    # 3. Insert Data
    log("\n--- Inserting Data ---")

    try:
        # Job Roles
        job_roles_data = [
            (1, 'Frontend', 'Next.js, React 기반 클라이언트 개발'),
            (2, 'Backend', 'Java, Spring 기반 서버 아키텍처 개발'),
            (3, 'Data/Python', 'Python 기반 데이터 모델링 및 AI 서비스 개발')
        ]
        cursor.executemany("INSERT INTO job_roles (role_id, role_name, description) VALUES (:1, :2, :3)", job_roles_data)

        # Rubric Categories
        categories_data = [
            (10, '기술적 숙련도', '선택한 스택의 깊이 있는 이해와 활용 능력', 0.5),
            (11, '문제 해결 및 설계', '장애 대응 및 효율적인 시스템 설계 역량', 0.3),
            (12, '협업 및 태도', '코드 품질 유지 및 기술 커뮤니케이션 능력', 0.2)
        ]
        cursor.executemany("INSERT INTO rubric_categories (category_id, name, description, weight) VALUES (:1, :2, :3, :4)", categories_data)

        # Evaluation Items
        eval_items_data = [
            (10, '기술 스택의 깊이', '사용하는 언어/프레임워크의 동작 원리를 이해하고 한계점을 인지하는가?'),
            (10, '시스템 설계 능력', '확장성과 유지보수를 고려하여 구조를 설계할 수 있는가?'),
            (11, '예외 처리 및 안정성', '해결책 제시 시 에지 케이스(Edge Case)와 예외 상황을 고려하는가?'),
            (12, '기술 커뮤니케이션', '기술적 개념을 비전공자나 동료가 이해하기 쉽게 설명할 수 있는가?')
        ]
        cursor.executemany("INSERT INTO evaluation_items (category_id, item_name, definition) VALUES (:1, :2, :3)", eval_items_data)

        # Companies
        companies_data = [
            (1, 'TechGiant', 'IT', '["Customer Obsession", "Ownership", "Frugality"]'),
            (2, 'FinSolutions', 'Finance', '["Trust", "Innovation", "Speed"]')
        ]
        cursor.executemany("INSERT INTO companies (company_id, name, industry, core_values) VALUES (:1, :2, :3, :4)", companies_data)

        # Job Postings
        postings_data = [
            (1, 2, 'Senior Java Engineer', '8+ years experience in Spring Boot, Microservices')
        ]
        cursor.executemany("INSERT INTO job_postings (company_id, role_id, title, requirements) VALUES (:1, :2, :3, :4)", postings_data)

        # Interview Questions (30 items)
        questions_data = [
            # Java/Spring (Role 2)
            (2, 10, 'Spring의 Bean 생명주기와 @PostConstruct의 용도를 설명해주세요.', '컨테이너 관리 이해', '생성->의존성주입->초기화 호출 순서 설명'),
            (2, 10, 'JDK Dynamic Proxy와 CGLIB Proxy의 차이를 설명해주세요.', 'AOP 원리 파악', '인터페이스 유무에 따른 프록시 생성 방식 차이'),
            (2, 11, '@Transactional 내부 호출 시 프록시 이슈 해결 방안은?', '트랜잭션 실무', 'Self-invocation 문제와 구조적 해결책'),
            (2, 10, 'JVM G1GC의 작동 방식과 장점을 설명해주세요.', '메모리 관리', '리전 기반 관리 및 STW 감소 원리'),
            (2, 10, 'Spring Security의 인증 필터 체인 흐름을 설명해주세요.', '보안 아키텍처', 'SecurityContextHolder 및 FilterChain 흐름'),
            (2, 11, 'JPA N+1 문제 해결을 위한 Fetch Join 활용법은?', '데이터 최적화', '지연 로딩 이슈와 최적화 쿼리 작성'),
            (2, 10, 'Spring Boot Auto Configuration의 작동 원리는?', '프레임워크 자동화', 'spring.factories를 통한 자동 설정 메커니즘'),
            (2, 11, 'ConcurrentHashMap이 HashMap보다 안전한 원리는?', '동시성 제어', 'Segment Lock 또는 CAS 연산 활용'),
            (2, 11, 'MSA 환경에서 서킷 브레이커의 역할은 무엇인가요?', '장애 전파 방지', '장애 시 호출 차단 및 시스템 보호'),
            (2, 12, 'Java 17의 Record 도입 시 이점은 무엇인가요?', '최신 문법 활용', '불변 데이터 객체화와 가독성 향상'),
            
            # Next.js (Role 1)
            (1, 10, 'Next.js SSR과 SSG의 적절한 사용 사례를 설명해주세요.', '렌더링 전략', '데이터 갱신 빈도에 따른 선택 기준'),
            (1, 10, 'Server Component와 Client Component의 경계는?', '최신 아키텍처', '서버 사이드 직렬화 및 클라이언트 상호작용 구분'),
            (1, 11, 'ISR을 활용한 정적 페이지 업데이트 방식을 설명해주세요.', '성능 최적화', 'revalidate를 통한 백그라운드 갱신'),
            (1, 10, 'SEO를 위한 Metadata API 활용 방안은?', '검색 엔진 최적화', '동적 메타데이터 생성 및 SEO 전략'),
            (1, 11, 'Next.js Image 컴포넌트가 성능에 주는 이점은?', '웹 최적화', 'Lazy Loading 및 이미지 리사이징'),
            (1, 10, 'Middleware를 이용한 인증 제어 구현 방법은?', '보안 및 라우팅', 'Edge Runtime 기반 리다이렉션 처리'),
            (1, 11, 'Hydration Error 발생 원인과 해결책은?', '디버깅 역량', '서버-클라이언트 HTML 불일치 해결'),
            (1, 11, 'Zustand나 React Query를 서버 컴포넌트와 조합하는 방법은?', '상태 관리 설계', 'Prefetching 및 Hydration 가이드'),
            (1, 10, 'Next.js의 Data Cache 메커니즘을 설명해주세요.', '캐싱 전략', 'fetch 요청 중복 제거 및 유지 기간'),
            (1, 11, 'T3 Stack과 같은 풀스택 구조의 장점은 무엇인가요?', '생산성/기술 스택', 'Type Safety와 엔드투엔드 타입 공유'),

            # Python (Role 3)
            (3, 10, 'Python GIL이 멀티 쓰레딩 성능에 미치는 영향은?', '언어 제약 이해', '싱글 쓰레드 실행 보장과 멀티프로세싱 필요성'),
            (3, 11, 'asyncio의 Event Loop 동작 원리를 설명해주세요.', '비동기 처리', 'I/O 바운드 작업의 논블로킹 처리 방식'),
            (3, 10, 'Python List와 Tuple의 메모리 관점 차이는?', '데이터 구조', '가변성 여부에 따른 최적화 방식'),
            (3, 11, 'Decorator를 활용한 실무 사례를 설명해주세요.', '코드 재사용', '로깅, 인증 등 횡단 관심사 분리'),
            (3, 10, 'Generator와 yield의 메모리 효율성을 설명해주세요.', '대용량 처리', 'Lazy Evaluation을 통한 이터레이터 활용'),
            (3, 11, 'FastAPI 의존성 주입(DI)의 장점은?', '프레임워크 활용', '코드 테스트 및 의존성 관리의 용이성'),
            (3, 10, 'Poetry와 같은 패키지 관리 도구의 필요성은?', '환경 관리', '결정론적 의존성 해결 및 환경 격리'),
            (3, 11, 'NumPy의 벡터화 연산이 빠른 이유는?', '연산 최적화', 'C 구현 루프 및 CPU 병렬 연산 활용'),
            (3, 11, 'Python의 순환 참조와 GC 대응 방법은?', '메모리 관리', '참조 횟수 계산 방식과 gc 모듈의 역할'),
            (3, 12, 'Python Type Hinting을 실무에서 쓰는 이유는?', '코드 품질', '정적 분석 및 협업 시 가독성 증대')
        ]
        cursor.executemany("INSERT INTO interview_questions (role_id, category_id, question_text, intent, ideal_answer) VALUES (:1, :2, :3, :4, :5)", questions_data)
        
        conn.commit()
        log("SUCCESS: All tables created and data inserted!")
        cursor.close()
        conn.close()
        
        # Create Success Flag File
        with open(r'c:\big20\final\setup_done.txt', 'w') as f:
            f.write("Done")
            
    except Exception as e:
        log(f"Error Inserting Data: {e}")

if __name__ == "__main__":
    setup_db()
